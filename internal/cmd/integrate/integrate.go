package integrate

import (
	"os"
	"path/filepath"
	"strings"

	copy2 "github.com/otiai10/copy"
	"github.com/pkg/errors"
	"github.com/pterm/pterm"
	"github.com/spf13/cobra"
	"golang.org/x/exp/maps"
	"golang.org/x/term"

	"code-intelligence.com/cifuzz/internal/cmdutils"
	"code-intelligence.com/cifuzz/internal/config"
	"code-intelligence.com/cifuzz/pkg/dialog"
	"code-intelligence.com/cifuzz/pkg/log"
	"code-intelligence.com/cifuzz/pkg/runfiles"
	"code-intelligence.com/cifuzz/util/fileutil"
	"code-intelligence.com/cifuzz/util/stringutil"
)

type integrateOpts struct {
	Interactive bool   `mapstructure:"interactive"`
	ProjectDir  string `mapstructure:"project-dir"`
	tools       []string
}

func (opts *integrateOpts) Validate() error {
	if opts.Interactive {
		opts.Interactive = term.IsTerminal(int(os.Stdin.Fd())) && term.IsTerminal(int(os.Stdout.Fd()))
	}

	if !opts.Interactive && len(opts.tools) == 0 {
		err := errors.New("Missing argument <git|cmake|vscode>")
		return cmdutils.WrapIncorrectUsageError(err)
	}

	return nil
}

type integrateCmd struct {
	*cobra.Command
	opts *integrateOpts
}

var supportedTools = map[string]string{
	"Git":     "git",
	"CMake":   "cmake",
	"VS Code": "vscode",
}

func New() *cobra.Command {
	return newWithOptions(&integrateOpts{})
}

func newWithOptions(opts *integrateOpts) *cobra.Command {
	var bindFlags func()

	cmd := &cobra.Command{
		Use:   "integrate <git|cmake|vscode>",
		Short: "Add integrations for the following tools: Git, CMake, VS Code",
		Long: `This command adds integrations for Git, CMake and VS Code:

` + pterm.Style{pterm.Reset, pterm.Bold}.Sprint("Git") + `
  Add files generated by cifuzz to your .gitignore:

    cifuzz integrate git

` + pterm.Style{pterm.Reset, pterm.Bold}.Sprint("CMake") + `
  Add CMake presets to your CMakeUserPresets.json. Those presets simplify
  the execution of regression tests from the command line and provide
  integration with IDEs such as CLion and VS Code:

    cifuzz integrate cmake

` + pterm.Style{pterm.Reset, pterm.Bold}.Sprint("VS Code") + `
  Provide integration for coverage runs from within VS Code by adding
  tasks to your tasks.json:

    cifuzz integrate vscode

Missing files are generated automatically.
`,
		ValidArgs: maps.Values(supportedTools),
		Args:      cobra.MatchAll(cobra.RangeArgs(0, len(supportedTools)), cobra.OnlyValidArgs),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			// Bind viper keys to flags. We can't do this in the New
			// function, because that would re-bind viper keys which
			// were bound to the flags of other commands before.
			bindFlags()

			opts.tools = args

			err := config.FindAndParseProjectConfig(opts)
			if err != nil {
				return err
			}

			return opts.Validate()
		},
		RunE: func(c *cobra.Command, args []string) error {
			cmd := integrateCmd{
				Command: c,
				opts:    opts,
			}

			return cmd.run()
		},
	}

	bindFlags = cmdutils.AddFlags(cmd,
		cmdutils.AddInteractiveFlag,
	)

	return cmd
}

func (c *integrateCmd) run() error {
	var err error

	if len(c.opts.tools) == 0 {
		selectedTools, err := selectTools()
		if err != nil {
			return err
		}
		c.opts.tools = selectedTools
	}

	for _, tool := range c.opts.tools {
		switch tool {
		case "git":
			err = setupGitIgnore(c.opts.ProjectDir)
			if err != nil {
				return err
			}
		case "cmake":
			err = setupCMakePresets(c.opts.ProjectDir, runfiles.Finder)
			if err != nil {
				return err
			}
		case "vscode":
			err = setupVSCodeTasks(c.opts.ProjectDir, runfiles.Finder)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// selectTools lets the user select the desired tools via an interactive multiselect dialog
func selectTools() ([]string, error) {
	selectedTools, err := dialog.MultiSelect("Select tools for integration", supportedTools)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	return selectedTools, nil
}

func setupGitIgnore(projectDir string) error {
	// Files to ignore for all build systems
	filesToIgnore := []string{
		"/.cifuzz-findings/",
	}

	buildSystem, err := config.DetermineBuildSystem(projectDir)
	if err != nil {
		return err
	}
	if buildSystem == config.BuildSystemCMake {
		filesToIgnore = append(filesToIgnore,
			"/.cifuzz-build/",
			"/CMakeUserPresets.json",
		)
	}
	if buildSystem == config.BuildSystemBazel {
		filesToIgnore = append(filesToIgnore, ".*_cifuzz_corpus/")
	} else {
		filesToIgnore = append(filesToIgnore, "/.cifuzz-corpus/")
	}

	gitIgnorePath := filepath.Join(projectDir, ".gitignore")
	hasGitIgnore, err := fileutil.Exists(gitIgnorePath)
	if err != nil {
		return err
	}

	if !hasGitIgnore {
		err = os.WriteFile(gitIgnorePath, []byte(strings.Join(filesToIgnore, "\n")), 0644)
		if err != nil {
			return errors.WithStack(err)
		}
	} else {
		bytes, err := os.ReadFile(gitIgnorePath)
		if err != nil {
			return errors.WithStack(err)
		}
		existingFilesToIgnore := stringutil.NonEmpty(strings.Split(string(bytes), "\n"))

		gitIgnore, err := os.OpenFile(gitIgnorePath, os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			return errors.WithStack(err)
		}
		defer gitIgnore.Close()

		for _, fileToIgnore := range filesToIgnore {
			if !stringutil.Contains(existingFilesToIgnore, fileToIgnore) {
				_, err = gitIgnore.WriteString(fileToIgnore + "\n")
				if err != nil {
					return errors.WithStack(err)
				}
			}
		}
	}
	log.Printf(`Added files generated by cifuzz to .gitignore.`)

	return nil
}

func setupVSCodeTasks(projectDir string, finder runfiles.RunfilesFinder) error {
	tasksSrcPath, err := finder.VSCodeTasksPath()
	if err != nil {
		return err
	}
	tasksDestPath := filepath.Join(projectDir, ".vscode", "tasks.json")
	hasTasks, err := fileutil.Exists(tasksDestPath)
	if err != nil {
		return err
	}

	if !hasTasks {
		// Situation: The user doesn't have a tasks.json file set up and
		// may thus be unaware of this functionality. Create one and tell
		// them about it.
		err = copy2.Copy(tasksSrcPath, tasksDestPath)
		if err != nil {
			return errors.WithStack(err)
		}
		log.Printf(`Created file .vscode/tasks.json. The 'cifuzz coverage (current test)'
task allows you to generate a coverage report for the currently opened
fuzz test source file in VS Code.

To learn more about tasks in VS Code, visit:

    https://code.visualstudio.com/docs/editor/tasks

Use the Coverage Gutters extension to display the coverage in VS Code:

    https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters

`)
	} else {
		// Situation: The user does have a tasks.json file set up, so we
		// assume them to know about the benefits. We suggest to the user
		// that they add our task to the existing tasks.json.
		presetsSrc, err := os.ReadFile(tasksSrcPath)
		if err != nil {
			return errors.WithStack(err)
		}

		log.Printf(`Add the following task to .vscode/tasks.json, which allows you to
generate a coverage report for the currently opened fuzz test source
file in VS Code:

%s

Use the Coverage Gutters extension to display the coverage in VS Code:

    https://marketplace.visualstudio.com/items?itemName=ryanluker.vscode-coverage-gutters

`, strings.TrimSpace(string(presetsSrc)))
	}

	return nil
}

func setupCMakePresets(projectDir string, finder runfiles.RunfilesFinder) error {
	presetsSrcPath, err := finder.CMakePresetsPath()
	if err != nil {
		return err
	}
	presetsDestPath := filepath.Join(projectDir, "CMakeUserPresets.json")
	hasPresets, err := fileutil.Exists(presetsDestPath)
	if err != nil {
		return err
	}

	if !hasPresets {
		// Situation: The user doesn't have a CMake user preset set up and
		// may thus be unaware of this functionality. Create one and tell
		// them about it.
		err = copy2.Copy(presetsSrcPath, presetsDestPath)
		if err != nil {
			return errors.WithStack(err)
		}
		log.Printf(`Created file CMakeUserPresets.json. This file contains presets which
simplify the execution of regression tests from the command line and
provide integration with IDEs such as CLion and VS Code.
This file should not be checked in to version control systems.
To learn more about CMake presets, visit:

    https://github.com/microsoft/vscode-cmake-tools/blob/main/docs/cmake-presets.md
    https://www.jetbrains.com/help/clion/cmake-presets.html`)
	} else {
		// Situation: The user does have a CMake user preset set up, so we
		// assume them to know about the benefits. We suggest to the user
		// that they add our preset to the existing CMakeUserPresets.json.
		presetsSrc, err := os.ReadFile(presetsSrcPath)
		if err != nil {
			return errors.WithStack(err)
		}

		log.Printf(`Add the following presets to your CMakeUserPresets.json. Those presets
simplify the execution of regression tests from the command line and
provide integration with IDEs such as CLion and VS Code:

%s`, presetsSrc)
	}

	return nil
}
